{"meta":{"title":"小蝌蚪(smallCoder)","subtitle":"我只是大自然的搬运工 务实 创新","description":"做最专业的 IT 人","author":"苟鸿人","url":"http://coder0007.com"},"pages":[{"title":"联系方式","date":"2017-12-14T08:24:49.000Z","updated":"2017-12-14T09:33:49.774Z","comments":true,"path":"about/index.html","permalink":"http://coder0007.com/about/index.html","excerpt":"","text":"请联系我 手机：15114018540 Email：373297055@qq.com QQ/微信号：15114018540"},{"title":"关于我","date":"2017-12-14T08:23:28.000Z","updated":"2017-12-14T08:23:28.273Z","comments":true,"path":"关于我/index.html","permalink":"http://coder0007.com/关于我/index.html","excerpt":"","text":""}],"posts":[{"title":"css3实现背景色渐变兼容所有浏览器","slug":"css3实现背景色渐变兼容所有浏览器","date":"2018-01-16T01:38:51.000Z","updated":"2018-01-16T03:12:01.607Z","comments":true,"path":"2018/01/16/css3实现背景色渐变兼容所有浏览器/","link":"","permalink":"http://coder0007.com/2018/01/16/css3实现背景色渐变兼容所有浏览器/","excerpt":"","text":"有时我们会看到网站上的一些图片是渐变色的，这些图片有的是ui设计出来的，有的则是直接通过css3制作出来的。下面就讲一下css3实现渐变色的方法，以及在各个浏览器上的兼容性。CSS3 Gradient分为linear-gradient(线性渐变)和radial-gradient(径向渐变)。 而我们今天主要是针对线性渐变来剖析其具体的用法。 为了更好的应用CSS3 Gradient,我们需要先了解一下目前的几种现代浏览器的内核，主流内核主要有Mozilla（Gecko）（熟悉的有Firefox，Flock等浏览器）、WebKit（熟悉的有Safari、Chrome等浏览器）、Opera(presto)（Opera浏览器）、Trident（讨厌的IE浏览器）。在ie下也可以实现渐变，不过要加滤镜。下面是代码：123456789101112131415161718.l-gradient&#123; /*火狐*/ background:-moz-linear-gradient(top, #AC07BD, #f6f6f8); /* Safari 4-5, Chrome 1-9*/ background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#AC07BD), to(#f140f8)); /*Safari5.1 Chrome 10+*/ background: -webkit-linear-gradient(top, #AC07BD, #f140f8); /*Opera 11.10+*/ background: -o-linear-gradient(top, #AC07BD, #f140f8); /*IE6 7*/ +background: #bada55; /*IE 8 9*/ -ms-FILTER: progid:DXImageTransform.Microsoft.Gradient(gradientType=0, startColorStr=#AC07BD, endColorStr=#f6f6f8); /* IE 10 */ background: -ms-linear-gradient(top, #AC07BD, #f6f6f8); /* Standard syntax; must be last */ linear-gradient(to bottom, hsl(0, 80%, 70%), #bada55); &#125; 代码解析： 代码10行到15行是在IE下实现渐变图解： 参数：代码第11行通过hack的办法直接设置了一个背景色，使不能看到渐变色的IE浏览器能够有一个背景色。如果也要显示显示背景色，那么就要通过背景图来实现。 代码第13行IE8、9依靠滤镜实现渐变。startColorstr表示起点的颜色，endColorstr表示终点颜色。GradientType表示渐变类型，0为缺省值，表示垂直渐变，1表示水平渐变。 代码第15行是一种带前缀的标准写法。 代码行6 线性渐变在Mozilla下的应用图解： 参数：其共有三个参数，第一个参数表示线性渐变的方向，top是从上到下、left是从左到右，如果定义成left top，那就是从左上角到右下角。第二个和第三个参数分别是起点颜色和终点颜色。你还可以在它们之间插入更多的参数，表示多种颜色的渐变。 代码行5和7 线性渐变在Webkit下的应用语法：1234//最新发布书写语法-webkit-linear-gradient( [&lt;point&gt; || &lt;angle&gt;,]? &lt;stop&gt;, &lt;stop&gt; [, &lt;stop&gt;]* )//老式语法书写规则-webkit-gradient(&lt;type&gt;, &lt;point&gt; [, &lt;radius&gt;]?, &lt;point&gt; [, &lt;radius&gt;]? [, &lt;stop&gt;]*) 图解： 参数：-webkit-gradient是webkit引擎对渐变的实现参数，一共有五个。第一个参数表示渐变类型（type），可以是linear（线性渐变）或者radial（径向渐变）。第二个参数和第三个参数，都是一对值，分别表示渐变起点和终点。这对值可以用坐标形式表示，也可以用关键值表示，比如 left top（左上角）和left bottom（左下角）。第四个和第五个参数，分别是两个color-stop函数。color-stop函数接受两个参数，第一个表示渐变的位置，0为起点，0.5为中点，1为结束点；第二个表示该点的颜色。 代码行9 线性渐变在Opera下的应用图解： 参数：-o-linear-gradient有三个参数。第一个参数表示线性渐变的方向，top是从上到下、left是从左到右，如果定义成left top，那就是从左上角到右下角。第二个和第三个参数分别是起点颜色和终点颜色。你还可以在它们之间插入更多的参数，表示多种颜色的渐变。 渐变上应用透明─透明度(Transparency)：透明度渐变background-image: linear-gradient(to bottom right, red, rgba(255,0,0,0)); 最后一个0代表透明度。如果所有点和长度使用依赖于background-size属性固定单元（百分比或关键字）定义，那么渐变背景不会被该属性影响。 透明度还支持透明渐变。这对于制作一些特殊的效果是相当有用的。1background: -moz-linear-gradient(right, rgba(255,255,255,0), rgba(255,255,255,1)); 参考及更多内容1、CSS3 Gradient2、CSS linear-gradiend3、css3实现颜色渐变以及兼容性处理 问题一：在实际的项目中，往往会碰到圆角和渐变的组合，如果使用上面的写法，那么在 ie9 下会有 bug（在 ie9 下背景色不能完全切完），解决方法是用SVG，具体点此查看","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://coder0007.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://coder0007.com/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://coder0007.com/tags/css3/"}]},{"title":"javascript基础学习","slug":"javascript基础学习","date":"2018-01-10T03:16:20.000Z","updated":"2018-01-10T04:13:40.918Z","comments":true,"path":"2018/01/10/javascript基础学习/","link":"","permalink":"http://coder0007.com/2018/01/10/javascript基础学习/","excerpt":"","text":"优秀的javascript学习博客1、阮一峰-JavaScript标准参考教程 基本语法1、语句javaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://coder0007.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://coder0007.com/tags/javascript/"},{"name":"ECMAscript5.1","slug":"ECMAscript5-1","permalink":"http://coder0007.com/tags/ECMAscript5-1/"}]},{"title":"太通安全企业关系情况","slug":"太通安全企业关系情况","date":"2017-12-20T03:19:53.000Z","updated":"2017-12-27T09:26:04.902Z","comments":true,"path":"2017/12/20/太通安全企业关系情况/","link":"","permalink":"http://coder0007.com/2017/12/20/太通安全企业关系情况/","excerpt":"","text":"太通安全科技有限公司 太通安全股权结构 主要人员 企业关系由企业关系可以找出与太通安全有关联的一些公司，那么这些公司哪些是太通安全并购的呢？逐一分析相关联的各个公司 南京久润安全科技有限公司 公司简介注册资金：2000万南京久润安全科技有限公司于2002年08月07日在南京市雨花台区市场监督管理局登记成立。法定代表人孙涛，公司经营范围包括安全技术研发；工程管理服务；建筑消防设施维修保养等。 财务信息 资产信息 主要人员 资质证书 太通建设有限公司 公司简介注册资金：5000万太通建设有限公司于1994年05月17日在怀柔分局登记成立。法定代表人唐九庆，公司经营范围包括专业承包；技术检测；消防产品的技术开发、技术咨询、技术服务；消防产品及设施的维护和保养；消防安全评估；房屋租赁；销售消防设备及器材、建筑材料、计算机配件、办公用品、水处理设备；水处理系统及设备的技术服务、技术咨询、技术开发。 财务信息 资产信息 人员信息 资质证书证书太多请点击天眼查 北京金玉航辉消防安全技术有限公司 公司简介注册资金：400万太通建设有限公司于2004年01月14日在海淀分局登记成立。法定代表人郭志伟，公司经营范围包括消防安全技术服务、技术咨询；电气防火检测、消防安全检测。 财务信息 资产信息 主要人员 资质证书没有，天眼查上面没有数据 北京城建太捷工程咨询有限责任公司 公司简介注册资金：500万北京城建太捷工程咨询有限责任公司成立于2013年08月19日，主要经营范围为建筑工程咨询；消防方面的技术检测；技术咨询；技术服务；技术开发、技术转让。 股东信息 资产信息 主要人员 资质证书没有，天眼查上面没有数据 中新房金襄（山西）精密工业有限公司 公司简介注册资金：1亿中新房金襄（山西）精密工业有限公司成立于2017年04月11日，主要经营范围为锻件制造，机械加工；道路货物运输:大型货物道路运输；物业服务；企业管理，商务咨询，广告制作、代理、发布，会议服务，企业策划；销售:日用百货、船舶配件、建筑材料、塑料制品、橡胶制品、玻璃制品、电气设备、机械设备、汽车配件、五金交电、化工产品(危险化学品除外)。 股东信息 资产信息 主要人员 资质证书没有，天眼查上面没有数据 鲲翔（北京）消防科技有限公司 公司简介注册资金：2000万鲲翔（北京）消防科技有限公司成立于2016年12月2日，主要经营范围为技术开发、技术推广、技术转让、技术咨询、技术服务；教育咨询（中介服务除外）。 股东信息 资产信息 主要人员 资质证书没有，天眼查上面没有数据 陕西坚瑞消防安全设备有限公司 公司简介注册资金：3000万陕西坚瑞消防安全设备有限公司成立于2016年2月29日，主要经营范围为一般经营项目：七氟丙烷气体灭火系统及装置、IG541气体灭火系统、干粉灭火系统及装置、细水雾灭火系统及装置的研发、生产与销售；消防工程系统、楼宇自动化控制系统的设计、安装；消防设备维修、保养；消防技术咨询服务；气体灭火系统监测、维护；消防气瓶检测、维修。货物及技术的进出口业务（国家限定或禁止公司经营的商品和技术除外）。 股东信息 资产信息 主要人员 资质证书没有，天眼查上面没有数据 陕西捷泰信消防安全设备有限公司 公司简介注册资金：3000万陕西坚瑞消防安全设备有限公司成立于2016年2月29日，主要经营范围为一般经营项目：七氟丙烷气体灭火系统及装置、IG541气体灭火系统、干粉灭火系统及装置、细水雾灭火系统及装置的研发、生产与销售；消防工程系统、楼宇自动化控制系统的设计、安装；消防设备维修、保养；消防技术咨询服务；气体灭火系统监测、维护；消防气瓶检测、维修。货物及技术的进出口业务（国家限定或禁止公司经营的商品和技术除外）。 股东信息 资产信息 主要人员 资质证书没有，天眼查上面没有数据 陕西坚瑞沃能股份有限公司 公司简介注册资金：24.33亿陕西坚瑞消防安全设备有限公司成立于2016年2月29日，主要经营范围为一般经营项目：七氟丙烷气体灭火系统及装置、IG541气体灭火系统、干粉灭火系统及装置、细水雾灭火系统及装置的研发、生产与销售；消防工程系统、楼宇自动化控制系统的设计、安装；消防设备维修、保养；消防技术咨询服务；气体灭火系统监测、维护；消防气瓶检测、维修。货物及技术的进出口业务（国家限定或禁止公司经营的商品和技术除外）。 股东信息（十大股东20170930） 资产信息 主要人员 资质证书没有，天眼查上面没有数据","categories":[],"tags":[]},{"title":"mybatis逆向工程生成源码","slug":"mybatis逆向工程生成源码","date":"2017-12-15T07:38:12.000Z","updated":"2017-12-27T09:13:42.703Z","comments":true,"path":"2017/12/15/mybatis逆向工程生成源码/","link":"","permalink":"http://coder0007.com/2017/12/15/mybatis逆向工程生成源码/","excerpt":"","text":"逆向工程字面意思就是反向生成工程, 和 Hibernate一样, MyBatis也有自己的逆向工程工具。详细信息请看官方文档 使用MyBatis逆向工程, 我们就不用再手动创建Model实体类以及对应的Mapper.xml文件和dao类；它可以直接连接数据库的表自动帮我们完成这些操作。是不是很方便？其实也只需要简单的几步就可以了。 首先我们从MyBatis的逆向工程Github仓库下载最新的jar包,还有MyBatis和MySQL的jar包。获取相关jar包点击百度云，密码：5703 逆向工程的配置1. 新建项目，导入Jar包使用IDEA新建一个Java项目，导入我们刚刚下载的三个jar包。[说明]怎么导入jar包呢？ 在java项目中新建一个文件夹lib,并将需要导入的jar包复制到lib文件夹中 选中jar包，右键点击“Build Path” ==&gt; “Add to Build Path “ 之后该jar包就已经成功添加到了java项目中了。此时你的java项目中多了一个Referenced Libraries 库，该库里面就是成功添加了相关jar包 包解析 mybatis-generator-core-1.3.5.jar （逆向工程核心包 ） mybatis-3.2.3.jar（MyBatis3.x jar包 ） mysql-connector-java-5.1.28-bin.jar（MySQL连接jar包） 2. 新建逆向工程的配置文件在src包下创建逆向工程的配置文件generatorConfig.xml,直接拷贝官方介绍中的XML配置即可.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 false:否 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC\" userId=\"root\" password=\"root\"&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认为false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer， 为true时，把JDBC DECIMAL 和 NUMERIC 类型解析为 java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成Model类的位置 --&gt; &lt;javaModelGenerator targetPackage=\"cn.huoyuwang.ssm.po\" targetProject=\".\\src\"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成mapper映射文件的位置 --&gt; &lt;sqlMapGenerator targetPackage=\"cn.huoyuwang.ssm.mapper\" targetProject=\".\\src\"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成Dao接口的位置 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"cn.huoyuwang.ssm.dao\" targetProject=\".\\src\"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库的表 --&gt; &lt;table tableName=\"book\"&gt;&lt;/table&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema=\"\" tableName=\"\"&gt; &lt;columnOverride column=\"\" javaType=\"\" /&gt; &lt;/table&gt; --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; XML内容都加了注释，我们只要修改几个地方就可以了 数据库连接信息 生成Model、Mapper、Dao 类的位置 数据库的表 table 3.执行代码在src包下新建一个Main.java 文件, 内容也是从官方那里Copy过来的123456789101112131415161718192021222324252627282930313233import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;public class Main &#123; public void generator() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //指定逆向工程de配置文件 File configFile = new File(\"src/generatorConfig.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; public static void main(String[] args) throws Exception&#123; // write your code here try &#123; Main generatorSqlmap = new Main(); generatorSqlmap.generator(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行程序，刷新程序。就会看到生成的如下源代码: 快速使用 github clone 用你的IDEA打开即可。","categories":[{"name":"技术","slug":"技术","permalink":"http://coder0007.com/categories/技术/"},{"name":"后端","slug":"技术/后端","permalink":"http://coder0007.com/categories/技术/后端/"},{"name":"java","slug":"技术/后端/java","permalink":"http://coder0007.com/categories/技术/后端/java/"},{"name":"mybatis","slug":"技术/后端/java/mybatis","permalink":"http://coder0007.com/categories/技术/后端/java/mybatis/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://coder0007.com/tags/后端/"},{"name":"java","slug":"java","permalink":"http://coder0007.com/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"http://coder0007.com/tags/mybatis/"}]},{"title":"我的简历","slug":"简历","date":"2017-12-14T08:25:31.000Z","updated":"2017-12-14T09:09:26.753Z","comments":true,"path":"2017/12/14/简历/","link":"","permalink":"http://coder0007.com/2017/12/14/简历/","excerpt":"","text":"联系方式 手机：15114018540 Email：373297055@qq.com QQ/微信号：15114018540 个人信息 苟鸿人/男/1990 本科/西南石油大学计算机系 工作年限：3年 技术博客：http://coder0007.github.io 期望职位：Web前端高级工程师，java后端中级工程师 期望薪资：税前月薪15k~20k，特别喜欢的公司可例外 期望城市：成都 工作经历ABC公司 （ 2012年9月 ~ 2014年9月 ）DEF项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 GHI项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） JKL公司 （ 2010年3月 ~ 2012年8月 ）MNO项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 PQR项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 技术文章（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你） 一个产品经理眼中的云计算：前生今世和未来 来自HeroKu的HTTP API 设计指南(翻译文章) （ 好的翻译文章可以侧证你对英文技术文档的阅读能力） 演讲和讲义（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义） 2014架构师大会演讲：如何通过Docker优化内部开发 9月公司内部分享：云计算的前生今世 技能清单以下均为我熟练使用的技能 Web开发：PHP/Hack/Node Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap 数据库相关：MySQL/PgSQL/PDO/SQLite 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer 单元测试：PHPUnit/SimpleTest/Qunit 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发 参考技能关键字 javascript css html jquery html5 ajax css3 java springmvc xml json bootstrap http nodejs angularjs mvc github mysql flex webapp 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","categories":[{"name":"简历","slug":"简历","permalink":"http://coder0007.com/categories/简历/"},{"name":"我的简历","slug":"简历/我的简历","permalink":"http://coder0007.com/categories/简历/我的简历/"}],"tags":[{"name":"简历","slug":"简历","permalink":"http://coder0007.com/tags/简历/"}]},{"title":"springMVC基础实战演练","slug":"springMVC基础学习","date":"2017-12-14T08:02:13.000Z","updated":"2018-01-10T09:53:16.858Z","comments":true,"path":"2017/12/14/springMVC基础学习/","link":"","permalink":"http://coder0007.com/2017/12/14/springMVC基础学习/","excerpt":"","text":"1. SpringMVC架构1.1 Spring web mvc介绍Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分,我们可以从Spring的整体结构中看得出来： 1.2 Web MVC1.2.1 架构图mvc设计模式在b/s系统下应用： 1.2.2 架构流程 用户发起request请求至控制器(Controller)，控制接收用户请求的数据，委托给模型进行处理。 控制器通过模型(Model)处理数据并得到处理结果，模型通常是指业务逻辑。 模型处理结果返回给控制器。 控制器将模型数据在视图(View)中展示，web中模型无法将数据直接在视图上显示，需要通过控制器完成。如果在C/S应用中模型是可以将数据在视图中展示的。 控制器将视图response响应给用户–通过视图展示给用户要的数据或处理结果。 1.3 Spring web mvc架构1.3.1 架构图 1.3.2 架构流程 用户发送请求至前端控制器(DispatcherServlet)。 前端控制器(DispatcherServlet)收到请求调用处理器映射器(HandlerMapping)–处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 前端控制器(DispatcherServlet)通过处理器适配器(HandlerAdapter)调用处理器–执行处理器(Controller，也叫后端控制器)，Controller执行完成返回ModelAndView对象；HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 DispatcherServlet将ModelAndView传给ViewReslover视图解析器–ViewReslover解析后返回具体View。 DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet响应用户 1.3.3 组件说明DispatcherServlet：前端控制器用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。HandlerMapping：处理器映射器HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。Handler：处理器Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。HandlAdapter：处理器适配器通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。View Resolver：视图解析器View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 2. 商品订单业务说明本教程在通过商品订单业务学习使用springmvc进行功能开发。 2.1 业务流程 管理员维护商品信息 用户挑选商品，购买，创建订单 2.2 数据库环境获取sql文件请点击百度云 ，密码：dwlw先导入sql_table.sql（表结构），再导入 sql_data.sql（表数据） 如图： 2.3 商品订单数据模型 3. SpringMVC入门3.1 需求实现商品查询列表功能。 3.2 开发环境准备本教程使用myEclipse+tomcat7开发 3.3 第一步:建立一个Web项目在myEclipse下创建动态web工程springmvc_first。步骤：File ==&gt; New ==&gt; Web Project如图：注意：选择java EE version选择javaEE5-web2.5,选择javaEE6或javaEE7生成的项目在WEB-INF目录下面找不到web.xml。 3.4 第二步:导入spring3.2.0的jar包需要spring3.2所有jar（一定包括spring-webmvc-3.2.0.RELEASE.jar）获取相关jar包请点击百度云，密码：p7qg把上面所有的jar包放入WebRoot/WEB-INF/lib目录中 3.5 第三步：前端控制器配置在WEB-INF目录下的web.xml写入 12345678910111213&lt;servlet&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; [说明] load-on-startup：表示servlet随服务启动； url-pattern：*.action的请交给DispatcherServlet处理。 contextConfigLocation：指定springmvc配置的加载位置，如果不指定则默认加载WEB-INF/[DispatcherServlet 的Servlet 名字]-servlet.xml。 3.5.1 Servlet拦截方式 拦截固定后缀的url，比如设置为 .do、.action， 例如：/user/add.action ,此方法最简单，不会导致静态资源（jpg,js,css）被拦截。 拦截所有，设置为/，例如：/user/add /user/add.action,此方法可以实现REST风格的url，很多互联网类型的应用使用这种方式；但是此方法会导致静态文件（jpg,js,css）被拦截后不能正常显示。需要特殊处理。 拦截所有，设置为/*，此设置方法错误，因为请求到Action，当action转到jsp时再次被拦截，提示不能根据jsp路径mapping成功。 3.6 第四步：springmvc配置文件Springmvc默认加载WEB-INF/[前端控制器的名字]-servlet.xml，也可以在前端控制器定义处指定加载的配置文件，如下： 1234&lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;&lt;/init-param&gt; 如上代码，通过contextConfigLocation加载classpath下的springmvc.xml配置文件。需要新建一个Source Folder：config步骤：鼠标右键springmvc_first ==&gt; New ==&gt; Source Folder 如下图：在config文件里面创建springmvc.xml 3.7 第五步：配置处理器适配器在springmvc.xml文件配置如下： 12345678910111213141516&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \"&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; &lt;/beans&gt; [说明]SimpleControllerHandlerAdapter：即简单控制器处理适配器，所有实现了org.springframework.web.servlet.mvc.Controller 接口的Bean作为Springmvc的后端控制器。 3.8 第六步：处理器开发在项目的src目录下新建两个Package：cn.huoyuwang.ssm.controller和cn.huoyuwang.ssm.po包说明：cn：域名huoyuwang：公司名或项目名ssm：项目框架controller：写得所有处理器放在里面po：实体类（po里面的实体类文件由mybatis逆向工程生成，生成的步骤请参考我的另一篇博客：mybatis逆向工程生成源码）在controller目录下新建一个class文件：itemList 123456789101112131415161718192021222324public class itemList implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request,HttpServletResponse response) throws Exception &#123; //商品列表 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); Items items_1 = new Items(); items_1.setName(\"联想笔记本\"); items_1.setPrice(6000f); items_1.setDetail(\"ThinkPad T430 联想笔记本电脑！\"); Items items_2 = new Items(); items_2.setName(\"苹果手机\"); items_2.setPrice(5000f); items_2.setDetail(\"iphone6苹果手机！\"); itemsList.add(items_1); itemsList.add(items_2); //创建modelAndView准备填充数据、设置视图 ModelAndView modelAndView = new ModelAndView(); //填充数据 modelAndView.addObject(\"itemsList\", itemsList); //视图 modelAndView.setViewName(\"order/itemsList\"); return modelAndView; &#125;&#125; org.springframework.web.servlet.mvc.Controller：处理器必须实现Controller 接口。ModelAndView：包含了模型数据及逻辑视图名 3.9第七步：配置处理器映射器在springmvc.xml文件配置如下：123&lt;!-- 处理器映射器 --&gt;&lt;!-- 根据bean的name进行查找Handler 将action的url配置在bean的name中 --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\" /&gt; BeanNameUrlHandlerMapping：表示将定义的Bean名字作为请求的url，需要将编写的controller在spring容器中进行配置，且指定bean的name为请求的url，且必须以.action结尾。 3.10第八步：处理器配置在springmvc.xml文件配置如下：12&lt;!-- controller配置 --&gt;&lt;bean name=\"/items.action\" id=\"itemList\" class=\"cn.huoyuwang.ssm.controller.itemList\"/&gt; name=”/items.action”：前边配置的处理器映射器为BeanNameUrlHandlerMapping，如果请求的URL 为“上下文/items.action”将会成功映射到itemList控制器。 3.11第九步：配置视图解析器在springmvc.xml文件配置如下：123456&lt;!-- ViewResolver --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;&lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; InternalResourceViewResolver：支持JSP视图解析viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包；prefix 和suffix：查找视图页面的前缀和后缀，最终视图的址为：前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp” 3.12第十步：视图开发创建/WEB-INF/jsp/itemsList.jsp视图页面：1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;商品列表：&lt;table width=\"100%\" border=1&gt;&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt;&lt;/tr&gt;&lt;c:forEach items=\"$&#123;itemsList &#125;\" var=\"item\"&gt;&lt;tr&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 3.13 第十一步：部署在tomcat测试通过请求：http://localhost:8080/springmvc_first/items.action如果页面输出商品列表就表明我们成功了！如图： 到这里商品查询列表的功能就实现了！但是你发现了什么问题呢？一是处理器映射器和处理器适配器只有这一种配置么，答案是否定的。二是我们的模型数据是硬编码，没有从数据库中得到。带着这些问题继续下面的学习 3.14 DispatcherServlet前端控制器DispathcerServlet作为springmvc的中央调度器存在，DispatcherServlet创建时会默认从spring-webmvc-xxx.jar包中的DispatcherServlet.properties文件加载springmvc所用的各种组件，如果在springmvc.xml中配置了组件则以springmvc.xml中配置的为准，DispatcherServlet的存在降低了springmvc各组件之间的耦合度。 3.15 非注解HandlerMapping处理器映射器HandlerMapping 负责根据request请求找到对应的Handler处理器及Interceptor拦截器，将它们封装在HandlerExecutionChain 对象中给前端控制器返回。下面介绍两种非注解的处理器映射器 BeanNameUrlHandlerMappingBeanNameUrl处理器映射器，根据请求的url与spring容器中定义的bean的name进行匹配，从而从spring容器中找到bean实例。这种非注解的处理器映射器正是上面配置用到的 12&lt;!—beanName Url映射器 --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; SimpleUrlHandlerMappingsimpleUrlHandlerMapping是BeanNameUrlHandlerMapping的增强版本，它可以将url和处理器bean的id进行统一映射配置。 123456789&lt;!-- 简单url映射器 --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;prop key=\"/items1.action\"&gt;controller的bean id&lt;/prop&gt; &lt;prop key=\"/items2.action\"&gt;controller的bean id&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 注意上面这两种映射器都要配合下面的代码，对于beanName Url映射器的controller配置不必要id，对于简单url映射器的controller配置不必要name，简单url映射配置里面的key值相当于bean 的name。12&lt;!-- controller配置 --&gt;&lt;bean name=\"/items.action\" id=\"itemList\" class=\"cn.huoyuwang.ssm.controller.itemList\"/&gt; 测试前面我们已经对beanName Url映射器做了测试，这里就不再测试。下面对简单的url映射器进行测试当然上面两种映射器是可以共存的，所以在springmvc.xml中配置如下：12345678910&lt;!--controller--&gt;&lt;bean id=\"itemList\" class=\"cn.huoyuwang.ssm.controller.itemList\" /&gt;&lt;!-- 简单url映射器 --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;prop key=\"/items1.action\"&gt;itemsList&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 如图所示：通过请求：http://localhost:8080/springmvc_first/items1.action如果页面输出商品列表就表明我们成功了！ 3.16 非注解HandlerAdapter处理器适配器HandlerAdapter会根据适配器接口对后端控制器进行包装（适配），包装后即可对处理器进行执行，通过扩展处理器适配器可以执行多种类型的处理器，这里使用了适配器设计模式。下面介绍两种非注解的处理器适配器 SimpleControllerHandlerAdapterSimpleControllerHandlerAdapter简单控制器处理器适配器，所有实现了org.springframework.web.servlet.mvc.Controller 接口的Bean通过此适配器进行适配、执行。上面的介绍已经对它进行了测试适配器配置如下： 1&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\" /&gt; HttpRequestHandlerAdapterHttpRequestHandlerAdapter，http请求处理器适配器，所有实现了org.springframework.web.HttpRequestHandler 接口的Bean通过此适配器进行适配、执行。上面两种处理器适配器也可以共存。 适配器配置如下： 1&lt;bean class=\"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter\"/&gt; 在controller文件下面新建itemList2.javaController实现如下： 12345678910111213141516171819202122232425public class itemList2 implements HttpRequestHandler &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 商品列表 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); Items items_1 = new Items(); items_1.setName(\"联想笔记本\"); items_1.setPrice(6000f); items_1.setDetail(\"ThinkPad T430 联想笔记本电脑！\"); Items items_2 = new Items(); items_2.setName(\"苹果手机\"); items_2.setPrice(5000f); items_2.setDetail(\"iphone5 苹果手机！\"); itemsList.add(items_1); itemsList.add(items_2); // 填充数据 request.setAttribute(\"itemsList\", itemsList); // 视图 request.getRequestDispatcher(\"/WEB-INF/jsp/order/itemsList.jsp\").forward(request, response); &#125;&#125; 从上边可以看出此适配器器的handleRequest方法没有返回ModelAndView，可通过response修改定义响应内容，比如返回json数据利用返回的json数据我们可以开发接口。123response.setCharacterEncoding(\"utf-8\");response.setContentType(\"application/json;charset=utf-8\");response.getWriter().write(\"json串\"); 测试1我们在springmvc.xml中加入1234&lt;!--controller配置--&gt;&lt;bean id=&quot;itemList2&quot; class=&quot;cn.huoyuwang.ssm.controller.itemList2&quot;/&gt;&lt;!--简单url映射器配置--&gt; &lt;prop key=&quot;/items2.action&quot;&gt;itemList2&lt;/prop&gt; 如图所示：通过请求：http://localhost:8080/springmvc_first/items2.action如果页面输出商品列表就表明我们配置成功了！ 测试2目的：我们要返回字符串1你好，我是字符串! 我们在springmvc.xml中加入1234&lt;!--controller配置--&gt;&lt;bean id=&quot;itemList3&quot; class=&quot;cn.huoyuwang.ssm.controller.itemList3&quot;/&gt;&lt;!--简单url映射器配置--&gt; &lt;prop key=&quot;/items3.action&quot;&gt;itemList3&lt;/prop&gt; 在controller中新建class文件：itemList3.java123456789public class itemList3 implements HttpRequestHandler &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"application/json;charset=utf-8\"); response.getWriter().write(\"你好，我是字符串\"); &#125;&#125; 通过请求：http://localhost:8080/springmvc_first/items3.action如果页面输出商品列表就表明我们配置成功了。在网页上我们可以看到如下内容：1你好，我是字符串 前面分别讲了两种非注解的处理器映射器和处理器适配器。下面讲解注解的映射器和适配器，这也是我们工作中使用的最多的方式。 3.17 注解映射器和适配器3.17.1 Controller的代码在controller文件甲下新建文件：itemList4，然后写下如下代码：1234567891011121314151617181920212223242526272829@Controllerpublic class itemList4 &#123; @RequestMapping(\"/queryItem.action\") public ModelAndView queryItem() &#123; // 商品列表 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); Items items_1 = new Items(); items_1.setName(\"联想笔记本\"); items_1.setPrice(6000f); items_1.setDetail(\"ThinkPad T430 联想笔记本电脑！\"); Items items_2 = new Items(); items_2.setName(\"苹果手机\"); items_2.setPrice(5000f); items_2.setDetail(\"iphone6苹果手机！\"); itemsList.add(items_1); itemsList.add(items_2); // 创建modelAndView准备填充数据、设置视图 ModelAndView modelAndView = new ModelAndView(); // 填充数据 modelAndView.addObject(\"itemsList\", itemsList); // 视图 modelAndView.setViewName(\"itemsList\"); return modelAndView; &#125;&#125; 上面代码我们可以看到多了@Controller和@RequestMapping(“/queryItem.action”)注解，@Controller表示itemList是一个后端处理器，@RequestMapping(“/queryItem.action”)表示queryItem方法是对应queryItem.action请求的映射,这样做的好处是可以在一个Controller里面写多个方法对应url请求另外我们发现上面的代码少了实现处理器适配器的接口和方法。 3.17.2 组件扫描器使用组件扫描器省去在spring容器配置每个controller类的繁琐。使用&lt;context:component-scan自动扫描标记@controller的控制器类，在springmvc.xml配置如下： 12&lt;!-- 扫描controller注解,多个包中间使用半角逗号分隔 --&gt;&lt;context:component-scan base-package=\"cn.huoyuwang.ssm.controller\"/&gt; 3.17.3 RequestMappingHandlerMapping注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。 在springmvc.xml配置如下：12&lt;!-- 注解映射器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/&gt; 注解描述：@RequestMapping：定义请求url到处理器功能方法的映射 3.17.4 RequestMappingHandlerAdapter注解式处理器适配器，对标记@ResquestMapping的方法进行适配。 从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。 在springmvc配置如下： 12&lt;!--注解适配器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/&gt; 测试通过请求：http://localhost:8080/springmvc_first/queryItem.action如果页面输出商品列表就表明我们配置成功了。 3.17.5 &lt;mvc:annotation-driven&gt; 注解驱动springmvc使用&lt;mvc:annotation-driven&gt;自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用&lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。开发中一般使用这个代替注解映射器和注解适配器 3.18 springmvc处理流程分析1、用户发送请求到DispatherServlet前端控制器 2、DispatherServlet调用HandlerMapping（处理器映射器）根据url查找Handler 3、DispatherServlet调用HandlerAdapter(处理器适配器)对HandlerMapping找到Handler进行包装、执行。HandlerAdapter执行Handler完成后，返回了一个ModleAndView(springmvc封装对象) 4、DispatherServlet拿着ModelAndView调用ViewResolver（视图解析器）进行视图解析，解析完成后返回一个View（很多不同视图类型的View） 5、DispatcherServlet进行视图渲染，将Model中数据放到request域，在页面展示 4. 整合mybatis为了更好的学习 springmvc和mybatis整合开发的方法，需要将springmvc和mybatis进行整合。 整合目标：控制层采用springmvc、持久层使用mybatis实现。 4.1 需求实现商品查询列表，从mysql数据库查询商品信息。 4.2jar包包括：spring（包括springmvc）、mybatis、mybatis-spring整合包、数据库驱动、第三方连接池。 参考：“mybatis与springmvc整合全部jar包”目录 ????? 4.3 Dao目标：1、spring管理SqlSessionFactory、mapper 详细参考mybatis教程与spring整合章节???????????? 4.3.1 db.properties在config文件下新建文件： db.properties； 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testspringmvcjdbc.username=XXXXjdbc.password=XXXX 4.3.2 log4j.properties在config文件下新建文件：log4j.properties；这是日志配置文件 123456# Global logging configuration，建议开发环境中要用debuglog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 4.3.3 sqlMapConfig.xml在classpath下创建mybatis/sqlMapConfig.xml1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;!—使用自动扫描器时，mapper.xml文件如果和mapper.java接口在一个目录则此处不用定义mappers --&gt;&lt;mappers&gt;&lt;package name=\"cn.itcast.ssm.mapper\" /&gt;&lt;/mappers&gt;&lt;/configuration&gt; 4.3.4 applicationContext-dao.xml在classpath下创建spring/applicationContext-dao.xml配置数据源、事务管理，配置SqlSessionFactory、mapper扫描器。123456789101112131415161718192021222324252627282930313233343536373839&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \"&gt;&lt;!-- 加载配置文件 --&gt;&lt;context:property-placeholder location=\"classpath:db.properties\"/&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;property name=\"maxActive\" value=\"30\"/&gt; &lt;property name=\"maxIdle\" value=\"5\"/&gt;&lt;/bean&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis/SqlMapConfig.xml\" /&gt;&lt;/bean&gt;&lt;!-- mapper扫描器 --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"cn.huoyuwang.ssm.mapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt;&lt;/bean&gt;&lt;/beans&gt; 4.3.5 ItemsMapper.xml前面讲到mybatis逆向工程，参考我的另一篇博客:mybatis逆向工程生成源码逆向工程会为我们自动生成 ItemsMapper.xml文件,我们需要把下面mapper里面的内容添加到页面里的mapper标签中去 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.huoyuwang.ssm.mapper.ItemsMapper\"&gt; &lt;!-- sql片段 --&gt; &lt;!-- 商品查询条件 --&gt; &lt;sql id=\"query_items_where\"&gt; &lt;if test=\"items!=null\"&gt; &lt;if test=\"items.name!=null and items.name!=''\"&gt; and items.name like '%$&#123;items.name&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; &lt;!-- 查询商品信息 --&gt; &lt;select id=\"findItemsList\" parameterType=\"queryVo\" resultType=\"items\"&gt; select * from items &lt;where&gt; &lt;include refid=\"query_items_where\"/&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 4.3.6 ItemsMapper.java在cn.huoyuwang.ssm.mapper文件夹下面新建接口文件：ItemsMapper1234public interface ItemsMapper &#123; //商品列表 public List&lt;Items&gt; findItemsList(QueryVo queryVo) throws Exception;&#125; 上面方法findItemsList传入的对象类型是QueryVo，很明显它是items的包装类，所以我们需要在cn.huoyuwang.ssm.po文件夹下面新建QueryVo 4.3.6 QueryVo.java123456789public class QueryVo &#123; Items iterm; public Items getIterm() &#123; return iterm; &#125; public void setIterm(Items iterm) &#123; this.iterm = iterm; &#125;&#125; 这样做的好处是我们可以对传入的参数进行扩展，而不仅仅局限于items实体类的那几个属性，扩展之后可以做关联查询 4.4 Service目标：1、Service由spring管理2、spring对Service进行事务控制。 4.4.1 applicationContext-service.xml在config/spring下创建applicationContext-service.xml 1234567891011121314151617&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \"&gt;&lt;!-- 商品管理的service --&gt;&lt;bean id=\"itemsService\" class=\"cn.huoyuwang.ssm.service.impl.ItemsServiceImpl\"/&gt;&lt;/beans&gt; 由上面的配置我们可以得知需要新建接口文件ItemsServiceImpl在classpath文件下新建包：cn.huoyuwang.ssm.Service.Impl 4.4.2 ItemsService1234public interface ItemsService &#123; //商品查询列表 public List&lt;Items&gt; findItemsList(QueryVo queryVo)throws Exception; &#125; 4.4.3 ItemsServiceImpl在classpath文件下新建包：cn.huoyuwang.ssm.Service 123456789 public class ItemsServiceImpl implements ItemsService&#123; @Autowired private ItemsMapper itemsMapper; @Override public List&lt;Items&gt; findItemsList(QueryVo queryVo) throws Exception &#123; //查询商品信息 return itemsMapper.findItemsList(queryVo); &#125; &#125; @Autowired因为前面的配置已经将ItemsMapper交给spring容器管理了，所以使用只需注入就行了。 4.4.4 applicationContext-transaction.xml配置事务管理器。在config/spring下创建applicationContext-transaction.xml 123456789101112131415161718192021222324252627282930313233343536&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \"&gt;&lt;!-- 事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!-- 通知 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 切面 --&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* cn.huoyuwang.ssm.service.impl.*.*(..))\"/&gt;&lt;/aop:config&gt;&lt;/beans&gt; 前面已经配置好了service和mapper，接下来只需要更改一下Controller就可以测试了 5 controller在Controller文件夹下面新建itemList5.java 1234567891011121314151617@Controllerpublic class itemList5 &#123; @Autowired private ItemsService itemsService; @RequestMapping(\"/queryItem1.action\") public ModelAndView queryItem() throws Exception &#123; // 商品列表 List&lt;Items&gt; itemsList = itemsService.findItemsList(null); // 创建modelAndView准备填充数据、设置视图 ModelAndView modelAndView = new ModelAndView(); // 填充数据 modelAndView.addObject(\"itemsList\", itemsList); // 视图 modelAndView.setViewName(\"itemsList\"); return modelAndView; &#125;&#125; 测试","categories":[{"name":"技术","slug":"技术","permalink":"http://coder0007.com/categories/技术/"},{"name":"后端","slug":"技术/后端","permalink":"http://coder0007.com/categories/技术/后端/"},{"name":"java","slug":"技术/后端/java","permalink":"http://coder0007.com/categories/技术/后端/java/"},{"name":"springmvc","slug":"技术/后端/java/springmvc","permalink":"http://coder0007.com/categories/技术/后端/java/springmvc/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://coder0007.com/tags/后端/"},{"name":"java","slug":"java","permalink":"http://coder0007.com/tags/java/"},{"name":"springmvc","slug":"springmvc","permalink":"http://coder0007.com/tags/springmvc/"}]},{"title":"hexo+github搭建个人博客","slug":"hexo-github搭建个人博客","date":"2017-12-14T07:55:45.000Z","updated":"2018-01-09T02:42:49.889Z","comments":true,"path":"2017/12/14/hexo-github搭建个人博客/","link":"","permalink":"http://coder0007.com/2017/12/14/hexo-github搭建个人博客/","excerpt":"","text":"什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 搭建步骤 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 安装Hexo 配置Hexo 怎样将Hexo与github page 联系起来 怎样发布文章 主题 推荐 主题Net的简单配置 添加sitemap和feed插件 添加404 公益页面 前提条件(环境准备) nodejs环境配置 git环境配置 github帐号注册 配置Node.js环境下载Node.js：nodejs链接，根据你自己的操作系统下载相应的安装包。注意：windows XP是安装不了的。如图所示： 保持默认设置即可，一路Next，安装很快就结束了。检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口： 在新打开的窗口中输入cmd，敲击回车，打开命令行界面。（下文将直接用打开命令行来表示以上操作，记住哦~）在打开的命令行界面中，输入12node -vnpm -v 说明：上面命令的意思的得到node和npm的版本号 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 配置git环境下载Git安装文件：GIt官网下载地址,根据自己的操作系统选择安装包。 然后就进入了Git的安装界面，如图： 和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择： Git PATH设置 这是对上图的解释，不需要了解请直接跳过 Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入：1git --version 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 github账户的注册和配置如果已经拥有账号，请跳过此步~ 第一步: Github注册打开github ，在下图的框中，分别输入自己的用户名，邮箱，密码。 点击创建按钮，进入到第二步，选择无限的免费的仓库，当然了，你也可以选择无限的付费的库 选择继续，然后前往自己刚才填写的邮箱，点开Github发送给你的注册确认信，确认注册，结束注册流程。 一定要确认注册，否则无法使用gh-pages！ 第二步: 创建代码库登陆之后，点击页面右上角的加号，选择New repository： 新建代码库 进入代码库创建页面： 在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示： 注意：比如我的github名称是gouhongren ,这里你就填 gouhongren.github.io,如果你的名字是zhangsan，那你就填 zhangsan.github.io 第三步: 代码库设置正确创建之后，你将会看到如下界面： 接下来开启gh-pages功能，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图： 点击Choose a theme，随意选择一个主题，点击select theme。 Github将会自动替你创建出一个gh-pages的页面。选择Commit changes。 如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~ 如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。到此搭建hexo博客的相关环境配置已经完成，下面开始讲解Hexo的相关配置 安装Hexo在自己认为合适的地方创建一个文件夹，这里我在桌面新建一个文件夹hexo；打开文件夹，右键选择Git Brash Here，如下图所示： 在命令行中输入：1npm install hexo -g 意思是通过nodejs的包管理组件npm在全局安装hexo（hexo是nodejs环境下的一个功能模块）然后你会看到 可能你会看到一个WARN，但是不用担心， 在命令行中输入：1hexo -v 如果你看到了如图文字，则说明已经安装成功了。 hexo的相关配置初始化Hexo 接着上面的操作，输入：1hexo init 然后输入：1npm install 之后npm将会自动安装你需要的组件，只需要等待npm操作即可。 首次体验Hexo继续操作，同样是在命令行中，输入：1hexo g 然后输入：1hexo s 然后会提示： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.在浏览器中打开http://localhost:4000/，你将会看到: 到目前为止，Hexo在本地的配置已经全都结束了。 下面会讲解怎样将Hexo与github page 联系起来 怎样将Hexo与github page 联系起来大概分为以下几步 配置git个人信息 配置Deployment 写博客、发布文章 配置git个人信息如果你之前已经配置好git个人信息，请跳过这一个 步骤，直接来到 设置Git的user name和email：(如果是第一次的话) 12git config --global user.name &quot;gouhongren&quot;git config --global user.email &quot;gouhongren@163.com&quot; 生成密钥 1ssh-keygen -t rsa -C &quot;gouhongren@163.com&quot; 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a，ctrl+c复制里面的所有内容 github配置ssh key然后进入github首页，点击右上角的小图标，选择setting，如图所示 进入下一个页面，选择SSH and GPK keys然后选择New SSH keys，如图： 进入下一个页面，title随便取名，key来自于前面id_rsa.pub里面的内容，点击Add SSH keys 如果显示如下页面表示添加ssh key成功 配置Deployment在项目hexo文件夹的根目录找到_config.yml,打开它在文本结尾找到deploy，然后按照如下修改：1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 在项目hexo文件夹的根目录找到_config.yml,打开它在文本结尾找到deploy，比如我的仓库的地址是https://github.com/gouhongren/gouhongren.github.io.git，所以配置如下1234deploy: type: git repo: git@github.com:gouhongren/gouhongren.github.io.git branch: master 写博客、发布文章新建一篇博客，执行下面的命令：(artical title这里是你自己要写博客的名称)1hexo new post &quot;我的第一篇博客&quot; 这时候在如下目录下 hexo\\source\\ _posts 将会看到 我的第一篇博客.md 文件 用MarDown编辑器（我使用的是HBuilder）打开就可以编辑文章了，这里需要了解一些基本的markdown写法，参考：点击我 ，很简单吧。 我们写下：1你好，欢迎来到我的个人技术博客。 如图： 文章编辑好之后，运行生成、部署命令： 12hexo g // 生成hexo s // 启动本地服务 在浏览器中输入：localhost:4000,就会看到： 那么如何把写的博客部署到远程仓库呢？只需要执行一条命令1hexo deploy #可以简写成hexo d 当然你也可以执行下面的命令，相当于生成和部署一步完成1hexo d -g #在部署前先生成 如果有如下信息：ERROR Deployer not found: git 需要用包管理器安装一个组件，如下：1npm install hexo-deployer-git -save 然后再次部署成功12hexo clean #清除本地生成的文件夹hexo g -d #生成和部署 然后访问gouhongren.github.io就可以看到如下页面，表示远程部署成功 NexT主题的配置1、安装 NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 下载主题 如果你熟悉 Git， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。 克隆最新版本下载稳定版本在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 2、启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件_config.yml， 找到 theme 字段，并将其值更改为 next。1theme: next 如图：到此，Next 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。注意：浏览器也可能会缓存，多刷新两遍。 3、验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000 ，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse 现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。 4、主题设定选择 Scheme Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白Mist - Muse 的紧凑版本，整洁有序的单栏外观Pisces - 双栏 Scheme，小家碧玉似的清新Gemini -双栏Scheme，博客之间有明显的区分Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面 注释 # 即可。 选择 Gemini Scheme1234#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 如图所示： 5、设置语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：1language: zh-Hans 目前 NexT 支持的语言如以下表格所示： 6、设置 菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）：设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项： 1234567891011menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 something: 有料 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 菜单图标配置示例 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的 Font Awesome 图标名字） 的情况下，NexT 将会使用 作为图标。请注意键值（如 home）的大小写要严格匹配 7、 侧栏默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：12left - 靠左放置right - 靠右放置 目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。12sidebar: position: left 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有：post - 默认行为，在文章页面（拥有目录列表）时显示always - 在所有页面中都显示hide - 在所有页面中都隐藏（可以手动展开）remove - 完全移除12sidebar: display: post 已知侧栏在 use motion: false 的情况下不会展示。 影响版本5.0.0及更低版本。 8、设置 头像编辑 站点配置文件， 新增字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 头像设置示例:1avatar: /images/logo-header.jpg 9、设置 作者昵称编辑 站点配置文件， 设置 author 为你的昵称。1author: gouhongren 10、站点描述编辑 站点配置文件， 设置 字段为你的站点描述。站点描述可以是你喜欢的一句签名1description: 务实求真知 nexT官方文档地址 添加插件1、添加sitemap和feed插件切换到你本地的hexo 目录，在命令行窗口，输入以下命令12npm install hexo-generator-feed -savenpm install hexo-generator-sitemap -save 修改_config.yml，增加以下内容 123456789101112# ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xml 2、百度统计注意： baidu_analytics 不是你的百度 id 或者 百度统计 id 登录 百度统计， 定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id，如： 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。12# Baidu Analytics IDbaidu_analytics: 10af06437690e7a3fb8acee3fb96af5f 再执行以下命令，部署服务端1hexo d -g 配完之后，就可以访问 https://gouhongren.github.io/atom.xml 和 https://gouhongren.github.io/sitemap.xml ，发现这两个文件已经成功生成了。 添加404 页面GitHub Pages有提供制作404页面的指引：Custom 404 Pages直接在根目录下创建自己的404.html或者404.md就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。 推荐使用腾讯公益404 我的404页面配置如下12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;gouhongren.github.io&quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考博客 手把手教你用Hexo+Github 搭建属于自己的博客 20分钟教你使用hexo搭建github博客 视屏推荐如果你觉得看博客看不太懂，推荐你看如下视屏百度云 密码：4ads","categories":[{"name":"技术","slug":"技术","permalink":"http://coder0007.com/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"http://coder0007.com/categories/技术/前端/"},{"name":"nodejs","slug":"技术/前端/nodejs","permalink":"http://coder0007.com/categories/技术/前端/nodejs/"},{"name":"hexo","slug":"技术/前端/nodejs/hexo","permalink":"http://coder0007.com/categories/技术/前端/nodejs/hexo/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://coder0007.com/tags/前端/"},{"name":"后端","slug":"后端","permalink":"http://coder0007.com/tags/后端/"},{"name":"hexo","slug":"hexo","permalink":"http://coder0007.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://coder0007.com/tags/博客/"}]}]}